# SDK – Learning Notes (beginner-friendly)
*author: <your name>*

> I wrote these notes as I was learning and building the SDK for **Search Hub**. If you’re new to this codebase, this is the “explain it like I’m new” version.

NEW ROUTES SOP:
1. write routes in API
2. update openapi.ts in schemas
3. pnpm --filter @search-hub/sdk generate
4. pnpm --filter api openapi:generate
5. update sdk/src/index

---

## 1) What is “the SDK” here?

- A **tiny TypeScript package** (`@search-hub/sdk`) that other parts of our project can import.
- It wraps `fetch` with a couple of **typed methods** like:
  - `client.search(...)` → calls `GET /v1/search`
  - `client.createDocument(...)` → calls `POST /v1/documents` (returns **202** because it’s async)
- The SDK **does not** touch the database. That’s the API’s job (API uses **Prisma**).
- Think of it as a **friendly remote control** for our API.

---

## 2) Why did I build it?

- I didn’t want **random fetch calls** all over the codebase with hand-written types.
- I wanted **TypeScript to warn me** when backend shapes change.
- I wanted the browser to call a **Next.js proxy route** (same origin) instead of the API directly (no CORS headaches).
- This pattern makes refactors **boring and safe**:
  1. Change Zod schema → 2. Regenerate types → 3. TS tells me what to update.

---

## 3) Where does it live?

```packages/sdk/
├─ src/
│ ├─ types.ts # auto-generated from OpenAPI (don’t edit by hand)
│ └─ index.ts # the tiny client I wrote
├─ package.json # scripts (generate, build)
└─ tsconfig.json
```

- `types.ts` is generated by **openapi-typescript** from `apps/api/openapi/openapi.json`.
- That `openapi.json` is generated by **zod-openapi** from our Zod schemas in `packages/schemas`.
- **Mental model:**
Zod Schemas → (zod-openapi) → openapi.json → (openapi-typescript) → types.ts → tiny client (index.ts)

---

## 4) How does it fit with the rest of the app?

Browser → Next.js proxy (/api/) → SDK → API (/v1/) → Prisma → Postgres

- **Browser** never calls the API directly (that avoids CORS and keeps secrets server-side).
- The **proxy route** in Next.js (server-side) uses the SDK.
- The **API** talks to the **DB** via Prisma (not the SDK!).

---

## 5) How does it actually work?

1. **Contracts (Zod)**: I define request/response shapes using Zod (e.g., `SearchQuery`, `CreateDocumentRequest`).
2. **OpenAPI**: I run a script that turns those Zod schemas into `openapi.json`.
3. **Types generation**: `openapi-typescript` turns the OpenAPI file into `src/types.ts` (a big `paths` object with exact types).
4. **Tiny client**: In `src/index.ts`, I import those types and write a very small class:
   - Builds URLs safely (`URLSearchParams`)
   - Adds headers
   - Parses JSON
   - Throws a simple `HttpError` with `status` + `body` so the proxy can pass through proper errors (like 400).

That’s it. The “magic” is the **types** — the client is intentionally boring.

---

## 6) How do I use it (quick examples)?

### In a Next.js proxy route
```ts
// apps/web/app/api/search/route.ts
import { SearchHubClient, HttpError } from "@search-hub/sdk";

export async function GET(req: Request) {
  const apiBase = process.env.API_URL!; // e.g., http://localhost:3000
  const url = new URL(req.url);

  const client = new SearchHubClient({ baseUrl: apiBase });

  try {
    const data = await client.search({
      tenantId: url.searchParams.get("tenantId") ?? "t1",
      q:        url.searchParams.get("q") ?? "",
      limit:    Number(url.searchParams.get("limit") ?? 10),
      offset:   Number(url.searchParams.get("offset") ?? 0),
    } as any);
    return Response.json(data);
  } catch (e) {
    if (e instanceof HttpError) {
      // Pass through real status (e.g., 400) so the UI gets the correct code
      return Response.json(e.body ?? { error: e.message }, { status: e.status });
    }
    return Response.json({ error: "upstream_failed" }, { status: 502 });
  }
}
```

## 7) Developer workflow
In the repo root I added these scripts:
```JSON
{
  "scripts": {
    "gen:api": "pnpm --filter api generate",
    "gen:sdk": "pnpm --filter @search-hub/sdk generate",
    "gen:all": "pnpm run gen:api && pnpm run gen:sdk"
  }
}
```

## 8) Timeline

1. Wrote Zod schemas (CreateDocument*, Search*, ApiError) with .meta() for docs.

2. Generated openapi.json using zod-openapi.

3. Generated packages/sdk/src/types.ts using openapi-typescript.

4. Wrote the tiny client (SearchHubClient) + HttpError.

5. Wired a Next.js proxy route that uses the SDK and passes through upstream errors.

6. Sanity-tested with curl and a small debug page.