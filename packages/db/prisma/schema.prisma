generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ---- enums ----
enum JobStatus {
  queued
  processing
  indexed
  failed
}

// ---- models ----
model Tenant {
  id           String             @id @default(cuid())
  name         String             
  memberships  TenantMembership[]
  documents    Document[]
  jobs         IndexJob[]
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt

  @@index([name])
}

model User {
  id           String             @id @default(cuid())
  email        String             @unique
  passwordHash String
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt

  memberships TenantMembership[]
}

model TenantMembership {
  id        String     @id @default(cuid())
  tenantId  String
  userId    String
  role      TenantRole @default(member)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([tenantId, userId])
  @@index([userId])
  @@index([tenantId])
}

enum TenantRole {
  owner
  admin
  member
}


model Document {
  id           String   @id @default(cuid())
  tenantId     String // viewbility 
  title        String
  source       String // "upload" | "url" | "api" (string for now; convert to enum later if stable)
  content      String?
  mimeType     String?
  searchVector Unsupported("tsvector") @default(dbgenerated("''::tsvector"))
  // future: size, checksum, storageKey, tags, etc.

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant     Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  jobs       IndexJob[]
  chunks     DocumentChunk[]     
  indexState DocumentIndexState?

  @@unique([tenantId, id])
  @@index([tenantId])
  @@index([title])
  @@index([tenantId, createdAt]) // supports WHERE tenantId ORDER BY createdAt
  @@index([searchVector], type: Gin, map: "Document_searchVector_idx")
}

model DocumentChunk {
  id         String                @id @default(cuid())
  tenantId   String
  documentId String
  idx        Int // chunk order within a document (0..N-1)
  content    String // the chunked text
  // 1024 for voyage
  embedding  Unsupported("vector") // vector(1024)
  createdAt  DateTime              @default(now())

  document Document @relation(fields: [tenantId, documentId], references: [tenantId, id], onDelete: Cascade)

  @@unique([documentId, idx])
  @@index([tenantId])
  @@index([documentId, idx])
}

// idempotency checkpoint
model DocumentIndexState {
  documentId    String   @id
  lastChecksum  String
  lastIndexedAt DateTime

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
}

model IndexJob {
  id         String @id @default(cuid())
  tenantId   String
  documentId String

  status JobStatus @default(queued)
  error  String? // capture failure reasons

  // future: attempts, durations, pipeline step metadata...

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([documentId])
  @@index([status])
  @@index([tenantId, documentId, status])
}
