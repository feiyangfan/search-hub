generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ---- enums ----
enum JobStatus {
  queued
  processing
  indexed
  failed
}

// ---- models ----
model Tenant {
  id           String             @id @default(cuid())
  name         String             
  memberships  TenantMembership[]
  documents    Document[]
  jobs         IndexJob[]
  tags         Tag[]
  searchLogs   SearchLog[]
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt

  @@index([name])
}

model User {
  id           String             @id @default(cuid())
  email        String             @unique
  name         String?
  passwordHash String?
  oauthProvider String?
  oauthAccountId String?
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt

  memberships TenantMembership[]
  createdDocuments Document[]      @relation("DocumentCreatedBy")
  updatedDocuments Document[]      @relation("DocumentUpdatedBy")
  favoriteDocuments DocumentFavorite[]
  documentCommands DocumentCommand[]
  createdTags Tag[]
  addedDocumentTags DocumentTag[]
  searchLogs SearchLog[]

  @@unique([oauthProvider, oauthAccountId])
}

model TenantMembership {
  id        String     @id @default(cuid())
  tenantId  String
  userId    String
  role      TenantRole @default(member)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([tenantId, userId])
  @@index([userId])
  @@index([tenantId])
}

enum TenantRole {
  owner
  admin
  member
}

enum DocumentSource {
  editor
  url
}

model Document {
  id           String   @id @default(cuid())
  tenantId     String   // viewbility 
  title        String
  source       DocumentSource @default(editor)
  sourceUrl    String?
  
  content      String?
  summary      String?
  metadata     Json?          @default("{}")
  searchVector Unsupported("tsvector") @default(dbgenerated("''::tsvector"))

  createdById String
  updatedById String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant     Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdBy User   @relation("DocumentCreatedBy", fields: [createdById], references: [id], onDelete: Cascade)
  updatedBy User   @relation("DocumentUpdatedBy", fields: [updatedById], references: [id], onDelete: Cascade)

  favorites DocumentFavorite[]
  commands  DocumentCommand[]
  jobs       IndexJob[]
  chunks     DocumentChunk[]     
  indexState DocumentIndexState?
  tags       DocumentTag[]

  @@unique([tenantId, id])
  @@index([tenantId])
  @@index([title])
  @@index([tenantId, createdAt]) // supports WHERE tenantId ORDER BY createdAt
  @@index([searchVector], type: Gin, map: "Document_searchVector_idx")
}

// Tags
model Tag {
  id  String @id @default(cuid())
  tenantId String // workspace-scoped
  name String // 'leetcode' / 'development'
  color String? // hex color
  description String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdById String

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdBy   User           @relation(fields: [createdById], references: [id], onDelete: Cascade)

  documentTags DocumentTag[]
  @@unique([tenantId, name]) // Tag names must be unique per workspace
  @@index([tenantId])
  @@index([name])
}

// Many-to-many relationship between Document and Tag
model DocumentTag {
  id         String   @id @default(cuid())
  documentId String
  tagId      String
  
  addedById  String   // who added this tag
  createdAt  DateTime @default(now())

  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  tag        Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)
  addedBy    User     @relation(fields: [addedById], references: [id], onDelete: Cascade)

  @@unique([documentId, tagId]) // A document can't have the same tag twice
  @@index([documentId])
  @@index([tagId])
  @@index([addedById])
}

// Favorites
model DocumentFavorite {
  id          String   @id @default(cuid())
  documentId  String  
  userId      String
  createdAt   DateTime @default(now())

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([documentId, userId])
  @@index([userId])
}

// command
model DocumentCommand {
  id          String @id @default(cuid())
  documentId  String 
  userId      String
  body       Json
  createdAt  DateTime @default(now())

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@index([userId])
}

model DocumentChunk {
  id         String                @id @default(cuid())
  tenantId   String
  documentId String
  idx        Int // chunk order within a document (0..N-1)
  content    String // the chunked text
  // 1024 for voyage
  embedding  Unsupported("vector") // vector(1024)
  createdAt  DateTime              @default(now())

  document Document @relation(fields: [tenantId, documentId], references: [tenantId, id], onDelete: Cascade)

  @@unique([documentId, idx])
  @@index([tenantId])
  @@index([documentId, idx])
  // NOTE: pgvector index managed manually in prisma/manual-migrations/01_pgvector_indexes.sql
  // Prisma doesn't support USING ivfflat syntax, so we maintain this externally
}

// idempotency checkpoint
model DocumentIndexState {
  documentId    String   @id
  lastChecksum  String
  lastIndexedAt DateTime

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
}

model IndexJob {
  id         String @id @default(cuid())
  tenantId   String
  documentId String

  status     JobStatus @default(queued)
  error      String? // capture failure reasons
  startedAt  DateTime? // when processing began (for accurate duration)
  completedAt DateTime? // when processing finished (indexed or failed)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant   Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([documentId])
  @@index([status])
  @@index([tenantId, documentId, status])
  @@index([createdAt(sort: Desc)]) // optimize recent job queries
}

// Search analytics and recent searches
model SearchLog {
  id           String   @id @default(cuid())
  tenantId     String
  userId       String
  query        String   // the search query text
  searchType   String   // 'lexical', 'semantic', 'hybrid'
  resultCount  Int      // number of results returned
  duration     Int      // milliseconds
  status       String   // 'success', 'error', 'partial'
  
  createdAt    DateTime @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([tenantId, userId, createdAt(sort: Desc)]) // recent searches per user
  @@index([tenantId, createdAt(sort: Desc)])         // tenant analytics
  @@index([tenantId, query])                         // top queries analysis
  @@index([createdAt(sort: Desc)])                   // time-series queries
}
